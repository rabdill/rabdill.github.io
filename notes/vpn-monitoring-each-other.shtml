<!--#include file="header1.html" -->VPN Boxes Monitoring Each Other<!--#include file="header2.html" -->



<h1>VPN Boxes Monitoring Each Other</h1>

<p class="indent">The situation: An Amazon VPC has an application that requires a VPN connection to another company's network. There are two externally routable subnets, and each one has an IPsec VPN connecting out. These VPN tunnels have the habit of closing without... telling anyone. This is not optimal, so we needed a way to monitor them.

<p class="indent">If the box crashes altogether, regular monitoring would work fine &ndash; but regular monitoring can't really tell if the VPN is still working. To avoid a situation where a box isn't capable of sending out an email that something isn't working, the two boxes are set up to check on each other.

<p class="indent">The script has two sections, which could run totally separetely if you wanted them to: First, it tries to hit a URL that will only be accessible if the VPN is up. If it can't, it restarts IPsec. If it <em>still</em> can't, it restarts the whole box. If it can't reach the URL after that too, it updates a web page called "status.html" saying it's down.

<p class="indent">The other part of the script looks for that status page on the <em>other</em> VPN: If it detects the page says it's down, it sends a message through Amazon's Simple Email Service saying it's down. If it can't find the page at all, it waits a bit, then tries again &ndash; that way, if the "down" VPN is in the middle of restarting itself (and can't respond to HTTP requests), it won't be marked as down until the box comes back up and... continues failing.

<p class="indent">In addition to the alert emails, the script also does another handy bit of 




<pre>#!/bin/bash 
source awsconnect.sh #loads API credentials for sending email

#  ** Set these to tell the box which it is, so it knows
#     what to monitor **
region=east
number=1

#translating that info into usuable data
if [[ "$region" == "west" ]]
then
        targetRegion="us-west-2"

        if [[ $number -eq 1 ]]
        then
                targetRTable="rtb-8606fde3" #the routing table ID
                instanceID="i-63ebc968"
                companionID="i-7221067f"
                companionIP="10.84.14.186"
        else
                targetRTable="rtb-8706fde2"
                instanceID="i-7221067f"
                companionID="i-63ebc968"
                companionIP="10.84.12.186"
        fi
else
        targetRegion="us-east-1"

        if [[ $number -eq 1 ]]
        then
                targetRTable="rtb-be66c2db"
                instanceID="i-9cd7ee73"
                companionID="i-a4a4534f"
                companionIP="10.84.10.186"
        else
                targetRTable="rtb-bf66c2da"
                instanceID="i-a4a4534f"
                companionID="i-9cd7ee73"
                companionIP="10.84.8.186"
        fi
fi


function log {
    current_time=`date +"%D %T"`
    echo "${current_time}: $1" >> /var/log/tunnel_monitor.log
}

function alert {
    current_timestamp=`date +"%s"`
    if [[ -f "alert.ticket" ]] #if it's already sent an alert email during this incident
    then
        read last_email < alert.ticket
        if [[ $((current_timestamp-last_email)) -gt 1800 ]]    #if it's been 30 minutes since the last email
        then
            log "Last alert was sent more than 30 minutes ago. Sending another."
            aws ses send-raw-email --raw-message file://vpnerror.json
            
            log "Updating alert.ticket with timestamp ${current_timestamp}."
            echo ${current_timestamp} > alert.ticket

        else
            log "Last alert was sent less than 30 minutes ago. Not sending another."
        fi
    else    #if this is the first alert of the incident
        log "No alert has been sent for this incident. Sending."
        aws ses send-raw-email --raw-message file://vpnerror.json

        log "Updating alert.ticket with timestamp ${current_timestamp}."
        echo ${current_timestamp} > alert.ticket

        log "Re-routing companion VPN's traffic through this one."
        ec2-replace-route $targetRTable -r 167.187.102.61/32 -i $instanceID --region $targetRegion -O $access_key -W $secret_key
    fi
}

function recovery {
    rm alert.ticket
    log "Sending recovery alert email."
    aws ses send-raw-email --raw-message file://vpnrecovery.json
    
    log "Updating routing table to direct traffic back to companion VPN."
    ec2-replace-route $targetRTable -r 167.187.102.61/32 -i $companionID --region $targetRegion -O $access_key -W $secret_key
}


# Check on connectivity to Hilton:
if `curl https://hte4.hilton.com:41111 --connect-timeout 20 &> /dev/null`
then
    echo "VPN UP" > /var/www/html/status.html
    if [[ -f "restart.ticket" ]]
    then
        [[ -f "alert.ticket" ]] && rm alert.ticket
        log "Box restarted, connection restored."
    fi

else
    if [[ -f "restart.ticket" ]]  #if it doesn't work even after restart
    then
        log "Box restarted, curl request still timing out. Declaring VPN down."
        echo "VPN DOWN" > /var/www/html/status.html

    else
        log "Connection to Hilton timed out. Checking ipsec..."
        # If Hilton times out but ipsec says we have a tunnel:
        if [[ `ipsec setup status | grep -c "[0-9] tunnels up"` -eq 1 ]]
        then
            $tunnels_up=`ipsec setup status | grep "tunnels up"`
            log "Despite https timeout to Hilton, ipsec reports $tunnels_up. Restarting ipsec."
        else
            if [[ `ps ax | grep -c ipsec` -gt 0 ]]
            then
                log "ipsec reporting no tunnels up. Restarting ipsec."
            else
                log "ipsec not running. Starting ipsec."
            fi
        fi
        service ipsec restart
        log "ipsec restarted. Waiting 30 seconds for connections."
        sleep 30
        if `curl https://hte4.hilton.com:41111 --connect-timeout 50 &> /dev/null`
        then    #if restarting ipsec fixed the timeout
            echo "VPN UP" > /var/www/html/status.html
            current_time=`date +"%D %T"`
            echo "${current_time}: Connection no longer timing out. VPN connection verified." >> /var/log/tunnel_monitor.log
            rm -f restart.ticket
        else    #if restarting the box didn't fix the timeout
            log "Connection still timing out. Restarting server."
            echo ${current_time} > restart.ticket
            shutdown -r now
        fi
    fi
fi


#### Check on the other VPN: ####
vpn_curl=`curl http://${companionIP}/status.html --connect-timeout 10`

if [[ `echo $vpn_curl | grep -c "VPN DOWN"` -eq 1 ]]
then
    log "Companion VPN reporting it is down."
    alert

else    #if the server isn't reporting it's down
    if [[ `echo $vpn_curl | grep -c "VPN UP"` -eq 0 ]]    #if it's not saying it's up either
    then
        log "Companion VPN not responding with anything intelligible. Retrying after 90 seconds."
        #try again
        sleep 90   #to prevent a box from 404ing mid-restart
        if [[ `curl http://${companionIP}/status.html --connect-timeout 15 | grep -c "VPN UP"` -eq 0 ]]
        then
            log "Still no response from companion VPN. Declaring companion VPN down."
            alert

        else    #if it responds when you try a second time
            log "Companion VPN now responding normally."
        fi
    else # if it works
        if [[ -f alert.ticket ]]    #if there's a current incident
        then
            log "Companion VPN reporting it is up again. All clear."
            recovery
        fi
    fi
fi












      <div class="footer">
        <p>&copy; 2014</p>
      </div>

    </div> <!-- /container -->


  </body>
</html>